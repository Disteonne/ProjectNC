INVERSION IF CONTROL
-Зависимость между объектами внедряется из ВНЕ (подается в аргумент конструктору и тд)
? где создать объект из вне
ответ: с помощью внедрения зависимостей  DEPENDENCY INJECTION

? как можно внедрять зависимости
ответ:
1.Через конструктор     +    <constructor-arg ref="" />
2.Внедрение ссылок      +
3.Setter                +    <property name="название сеттера без 'set''" ref="musicBean" />
4.Из внешнего файла     +    applicationContext.xml
5.Множество конфигураций scope,init-method,destroy-method,factory-method...
6.Через XML,JAVA аннотации или Java-код
7.Процесс можно автоматизировать (Autowiring)


SCOPE - ОБЛАСТЬ ВИДИМОСТИ БИНОВ
-задает то,как spring создаст этот бин.(по умолчанию создается Singleton-один объект до вызова метода getBean(),при
            всех вызовах getBean() возвращается ссылка на единственный созданный объект)
            Чаще используется.когда у нашего бина нет изменяемых состояний(если будем изменять=проблема)
            П: если хотя бы один изменит состояние.то оно автоматически изменит состояние и у другиъ бинов
            Можно указать явно: scope="singleton"

  Виды:
-singleton;
-prototype-каждый раз при вызове getBean() создает новый объект.Чаще всего применяется.когда у бина изменяемое состояние;
-request; MVC
-session; MVC
-global-session; MVC



    ЖИЗНЕННЫЙ ЦИКЛ БИНА
 Запуск Spring приложения -> запуск спринг контейнера (контекст) -> создается объект бина ->в бин внедряются зависимости ->
 -> вызывается указанный INIT METHOD (вызывает при создании бина) -> бин готов к использованию ->
 -> вызывается указанный DESTROY METHOD (автоматически вызывается при удалении) ->
 -> остановки spring приложения.

 init-method="ИМЯ_МЕТОДА"
 -запускается в ходе инициализации бина;
 -инициализация ресурсов, обращение к внешним файлам, запуск БД;

 destroy-method="ИМЯ_МЕТОДА"
 -запускается в ходе удалении бина;
 -очищение ресурсов, закрытие потоков ввода-вывода,закрытие доступа к БД;

 init-method,destroy-method:
-модификатор доступа: абсолютно любой
-может быть любой,но чаще всего void
-название метода мб любым
-НЕ ДОЛЖНЫ ПРИНИМАТЬ НИКАКИХ ВХОДНЫХ ПАРАМЕТРОВ В МЕТОДАХ
-(!!!) для бинов со scope="prototype" спринг НЕ ВЫЗЫВАЕТ DESTROY-METHOD

 factory-method="ИМЯ_МЕТОДА"
 -создает объект не напрямую (через new), а через вызов особого фабричного метода.Объекты все равно будут создаваться
 через new,но делать это будет фабричный метод (иногда это бывает полезно).Паттерн.
 Метод должен быть статическим
 -при использовании scope="prototype" будет использоваться лишь один объект( как в случае с обычным синглотоном)



        АННОТАЦИИ
-spring находит классы со спец аннотациями и автоматически создает бины из этих классов
    @Component - помечаем дял создания бина этого класса. Можно указать id, тогда будет назв_класса_с_мал_буквы
    @Autowired-подбирает подходящие бины по их типу (класс или интерфейс)
        1.спринг сканирует все классы и создает бины с аннотацией @Component
        2.сканирует все созданные бины и проверяет,подходит ли хотя бы один бин в качестве зависимости там, где указали
        @Autowired
        3.Если находится текущий бин.то он внедряется в качестве зависимости
        Если не находится ни одного-ОШИБКА
        Если несколько-НЕОДНАЗНАЧНОСТЬ
    Можно использовать на полях, на set и конструкторах + даже  в приватное поле,если нет конструктора или set(спс рефлексия)
